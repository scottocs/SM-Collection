package main

/*
 发现提供的的国密包一个问题，SM4部分没有提供操作模式，只能加密定长的消息。应要求提供gcm模式，以及cbc模式加pkcs5padding填充



*/
import "SM/SM4"
import "fmt"

//import "fmt"

func main() {
	/*
		fmt.Println("<START/>")

		//SM.SM4_SelfCheck()

		var key = []uint8{0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10}
		var plain = []uint8{0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10}

		//var key = []uint8{0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30}
		//var plain = []uint8{0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31}

		var CypherText =  SM4.SM4_En( key, plain)

		fmt.Println(CypherText)

		fmt.Println("<END/>")
	*/

	//SM4.GF_init(8)    //means 2^8
	//SM4.GF_init(8)

	// MulResult := SM4.GFmul( 0x00000057, 0x00000083)
	// MulResult := SM4.GFmul( 87, 131)
	/*
		fmt.Printf("%x", MulResult)
	*/
	//MulResult := SM4.GFmul( 3, 7)    //ok
	//MulResult := SM4.GFmul( 129, 5)

	//fmt.Printf("%d\n", MulResult)
	//fmt.Printf("%x\n", MulResult)
	//fmt.Printf("%b\n", SM4.Prim_poly)

	var Text = []uint8{0x01, 0x23, 0x45, 0x67}
	var IV = []uint8{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	var key = []uint8{0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30}
	CypherText := SM4.SM4_En_CBC_Mode(Text, IV, key)

	DecypherText := SM4.SM4_De_CBC_Mode(CypherText, IV, key)

	fmt.Printf("Text::%d\n", Text)
	fmt.Printf("CypherText::%d\n", CypherText)
	fmt.Printf("DecypherText::%d\n", DecypherText)
	/**/
	/*
		var _Text = []uint8{0x01,0x23,0x45,0x67}
		var _IV = []uint8{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
		var _CTR uint32 = 1234567890;
		var _key = []uint8{0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30}
		_CypherText := SM4.SM4_En_GCM_Mode(_Text, _IV, _key)

		_DecypherText := SM4.SM4_De_GCM_Mode(_CypherText, _IV, _key)

		fmt.Printf("Text::%d\n", _Text)
		fmt.Printf("CypherText::%d\n", _CypherText)
		fmt.Printf("DecypherText::%d\n", _DecypherText)
	*/
	var _Text = []uint8{0x01, 0x23, 0x45, 0x67}
	var _IV = []uint8{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} //12Bytes(96bits)
	var _CTR uint32 = 0x12345678
	var _key = []uint8{0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30}
	var _HashKey = []uint8{0x0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0xf0, 0xff}

	//Result := SM4.Uint32_to_Uint8(_CTR)
	_CypherText, _MAC := SM4.SM4_En_GCM_Mode(_Text, _IV, _CTR, _key, _HashKey)
	_DeCypherText := SM4.SM4_De_GCM_Mode(_CypherText, _IV, _CTR, _key, _HashKey, _MAC)

	fmt.Printf("_IV:: %x\n", _IV)
	fmt.Printf("_CTR:: %x\n", _CTR)
	fmt.Printf("_key:: %x\n", _key)
	fmt.Printf("_HashKey:: %x\n", _HashKey)
	fmt.Printf("_Text:: %x\n", _Text)
	fmt.Printf("_MAC:: %x\n", _MAC)
	fmt.Printf("_CypherText:: %x\n", _CypherText)
	fmt.Printf("_DeCypherText:: %x\n", _DeCypherText)
}
